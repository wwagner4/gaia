package gaia

import gaia.Data.Star

import java.nio.file.Path
import scala.util.Random

object X3d {

  case class Vec(x: Double, y: Double, z: Double) {
    def strComma = s"$x, $y, $z"

    def strNoComma = s"$x $y $z"

    def mul(factor: Double): Vec = Vec(x * factor, y * factor, z * factor)

    def add(other: Vec): Vec = Vec(x + other.x, y + other.y, z + other.z)

    def length: Double = math.sqrt((x * x) + (y * y) + (z * z))

    def sprod(other: Vec): Double = (x * other.x) + (y * other.y) + (z * other.z)

    def angle(other: Vec): Double = math.acos(sprod(other) / (length * other.length)) * 180 / math.Pi

  }

  def test(id: String): Unit = {
    Palette.p1c10.colors.foreach(println(_))
  }

  /**
   * Palettes generated by https://colorbrewer2.org/
   */
  enum Palette(brew: String) {

    case p1c10 extends Palette("['rgb(158,1,66)','rgb(213,62,79)','rgb(244,109,67)','rgb(253,174,97)','rgb(254,224,139)','rgb(230,245,152)','rgb(171,221,164)','rgb(102,194,165)','rgb(50,136,189)','rgb(94,79,162)']")

    case p1c5 extends Palette("['rgb(215,25,28)','rgb(253,174,97)','rgb(255,255,191)','rgb(171,217,233)','rgb(44,123,182)']")

    case p2c10 extends Palette("['rgb(165,0,38)','rgb(215,48,39)','rgb(244,109,67)','rgb(253,174,97)','rgb(254,224,144)','rgb(224,243,248)','rgb(171,217,233)','rgb(116,173,209)','rgb(69,117,180)','rgb(49,54,149)']")

    def colors: Seq[Color] = {
      val r = """rgb\((.*?)\)""".r
      val colorStrings = for (m <- r.findAllMatchIn(brew)) yield m.group(1)
      for (cs <- colorStrings.toSeq) yield {
        val vals = cs.split(",")
        val r = vals(0).toDouble / 256
        val g = vals(1).toDouble / 256
        val b = vals(2).toDouble / 256
        Color(r, g, b)
      }
    }
  }

  object Vec {
    def zero = Vec(0.0, 0.0, 0.0)
  }

  case class Vec2(x: Double, y: Double) {

    def strComma = s"$x, $y"

    def strNoComma = s"$x $y"
  }


  case class Color(r: Double, g: Double, b: Double) {
    def strNoComma = s"$r $g $b"

    def mul(factor: Double): Color = {
      def adj(v: Double) = math.min(math.max(0.0, v), 1.0)

      Color(adj(r * factor), adj(g * factor), adj(b * factor))
    }
  }

  object Color {

    def random: Color = {
      val r = Random.nextDouble()
      val g = Random.nextDouble()
      val b = Random.nextDouble()
      Color(r, g, b)
    }

    def red = Color(1, 0, 0)

    def darkRed = Color(0.5, 0, 0)

    def veryDarkRed = Color(0.25, 0, 0)

    def yellow = Color(1, 1, 0)

    def orange = Color(1, 0.5, 0)

    def green = Color(0, 1, 0)

    def darkGreen = Color(0.01, 0.2, 0.01)

    def veryDarkGreen = Color(0.0001, 0.08, 0.0001)

    def blue = Color(0, 0, 1)

    def darkBlue = Color(0.1, 0.1, 0.2)

    def veryDarkBlue = Color(0.0001, 0.0001, 0.05)

    def black = Color(0, 0, 0)

    def white = Color(1, 1, 1)

    def gray(brightness: Double): Color = {
      val b = math.max(math.min(1.0, brightness), 0.0)
      Color(b, b, b)
    }

  }

  trait Shapable {
    def toShape: String
  }

  object Shapable {

    case class Cylinder(translation: Vec, color: Color, radius: Double = 1.0, height: Double = 1.0,
                        rotation: Vec = Vec.zero) extends Shapable {
      def toShape = {
        s"""
           |<Transform translation='${translation.strNoComma}'>
           |<Transform rotation='1 0 0 ${rotation.x}' center='0, 0, 0'>
           |<Transform rotation='0 1 0 ${rotation.y}' center='0, 0, 0'>
           |<Transform rotation='0 0 1 ${rotation.z}' center='0, 0, 0'>
           |  <Shape>
           |     <Cylinder radius='$radius' height='$height'/>
           |     <Appearance>
           |       <Material diffuseColor='${color.strNoComma}'/>
           |     </Appearance>
           |   </Shape>
           |</Transform>
           |</Transform>
           |</Transform>
           |</Transform>
           |""".stripMargin
      }
    }

    case class Box(translation: Vec, rotaion: Vec = Vec.zero, color: Color = Color.orange, size: Vec = Vec(1, 1, 1),
                   solid: Boolean = true) extends Shapable {
      def toShape = {
        s"""
           |<Transform translation='${translation.strNoComma}'>
           |<Transform rotation='1 0 0 ${rotaion.x}' center='0, 0, 0'>
           |<Transform rotation='0 1 0 ${rotaion.y}' center='0, 0, 0'>
           |<Transform rotation='0 0 1 ${rotaion.z}' center='0, 0, 0'>
           |  <Shape>
           |     <Box size='${size.strNoComma}' solid='$solid'/>
           |     <Appearance>
           |       <Material diffuseColor='${color.strNoComma}'/>
           |     </Appearance>
           |   </Shape>
           |</Transform>
           |</Transform>
           |</Transform>
           |</Transform>
           |""".stripMargin
      }
    }

    case class PointSet(positions: Iterable[Vec], color: Color = Color.orange)
      extends Shapable {
      val points = positions.map(_.strNoComma).mkString(" ")
      val colors = points.map(_ => color.strNoComma).mkString(" ")

      def toShape = {
        s"""
           |<Shape>
           |<PointSet>
           |  <Color color='$colors' />
           |  <Coordinate point='$points'/>
           |  </PointSet>
           |</Shape>
           |""".stripMargin
      }
    }

    case class Sphere(translation: Vec, color: Color = Color.orange, radius: Double = 1.0,
                      solid: Boolean = false) extends Shapable {
      def toShape = {
        s"""
           |<Transform translation='${translation.strNoComma}'>
           |  <Shape>
           |     <Sphere radius='${radius}' solid='$solid'/>
           |     <Appearance>
           |       <Material diffuseColor='${color.strNoComma}'/>
           |     </Appearance>
           |   </Shape>
           |</Transform>
           |""".stripMargin
      }
    }

    case class Line(start: Vec = Vec.zero, end: Vec = Vec(1, 0, 0), startColor: Color = Color.white,
                    endColor: Color = Color.yellow, zoom: Double = 1.0) extends Shapable {
      def toShape = {
        val s = start.mul(zoom)
        val e = end.mul(zoom)
        s"""
           |<Shape>
           |<IndexedLineSet colorIndex='0 1 -1' coordIndex='0 1 -1'>
           |  <Color color='${startColor.strNoComma} ${endColor.strNoComma}'/>
           |  <Coordinate point='${s.strNoComma}  ${e.strNoComma}'/>
           |</IndexedLineSet>
           |</Shape>
           |""".stripMargin
      }
    }

  }

  def createXml(shapables: Seq[Shapable], title: String, backColor: Color): String = {

    val shapablesStr = shapables.map(_.toShape).mkString("\n")
    s"""<?xml version="1.0" encoding="UTF-8"?>
       |<!DOCTYPE X3D PUBLIC "ISO//Web3D//DTD X3D 3.3//EN" "https://www.web3d.org/specifications/x3d-3.3.dtd">
       |<X3D profile='Interchange' version='3.3' xmlns:xsd='http://www.w3.org/2001/XMLSchema-instance' xsd:noNamespaceSchemaLocation='https://www.web3d.org/specifications/x3d-3.3.xsd'>
       |  <head>
       |    <meta content='http://entelijan.net' name='reference'/>
       |  </head>
       |  <Scene>
       |    <WorldInfo title='$title'/>
       |    <Background skyColor='${backColor.strNoComma}'/>
       |    $shapablesStr
       |  </Scene>
       |</X3D>""".stripMargin
  }

  def drawTo(outfile: Path, drawable: X3d.Color => Seq[X3d.Shapable], backColor: X3d.Color) = {
    val shapables = drawable(backColor)
    val xml = X3d.createXml(shapables, outfile.getFileName.toString, backColor)
    gaia.Util.writeString(outfile, xml)
  }


}
